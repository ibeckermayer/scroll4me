package digest

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/ibeckermayer/scroll4me/internal/types"
)

// Builder creates markdown digest files from analyzed posts
type Builder struct {
	outputDir string
	maxPosts  int
}

// New creates a new digest builder
func New(outputDir string, maxPosts int) *Builder {
	return &Builder{
		outputDir: outputDir,
		maxPosts:  maxPosts,
	}
}

// Content holds the rendered digest content (pure data, no side effects).
type Content struct {
	Markdown  string
	PostCount int
	CreatedAt time.Time
}

// Digest represents a saved digest file.
type Digest struct {
	FilePath  string
	PostCount int
	CreatedAt time.Time
}

// Render generates markdown content from analyzed posts without writing to disk.
func (b *Builder) Render(posts []types.PostWithAnalysis, totalScraped int) (*Content, error) {
	if len(posts) == 0 {
		return nil, fmt.Errorf("no posts to include in digest")
	}

	// Sort by relevance score descending
	sort.Slice(posts, func(i, j int) bool {
		if posts[i].Analysis == nil {
			return false
		}
		if posts[j].Analysis == nil {
			return true
		}
		return posts[i].Analysis.RelevanceScore > posts[j].Analysis.RelevanceScore
	})

	// Limit to max posts
	if len(posts) > b.maxPosts {
		posts = posts[:b.maxPosts]
	}

	now := time.Now()
	markdown := b.buildMarkdown(posts, now, totalScraped)

	return &Content{
		Markdown:  markdown,
		PostCount: len(posts),
		CreatedAt: now,
	}, nil
}

// Save writes the digest content to the user-configured output directory.
// Returns the saved Digest with file path.
func (b *Builder) Save(content *Content) (*Digest, error) {
	// Ensure output directory exists
	if err := os.MkdirAll(b.outputDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create output directory: %w", err)
	}

	// Generate filename
	filename := fmt.Sprintf("%s-digest.md", content.CreatedAt.Format("2006-01-02-150405"))
	filePath := filepath.Join(b.outputDir, filename)

	// Write file
	if err := os.WriteFile(filePath, []byte(content.Markdown), 0644); err != nil {
		return nil, fmt.Errorf("failed to write digest file: %w", err)
	}

	return &Digest{
		FilePath:  filePath,
		PostCount: content.PostCount,
		CreatedAt: content.CreatedAt,
	}, nil
}

// Build creates a markdown digest from analyzed posts and saves it to disk.
// This is a convenience method that calls Render + Save.
func (b *Builder) Build(posts []types.PostWithAnalysis, totalScraped int) (*Digest, error) {
	content, err := b.Render(posts, totalScraped)
	if err != nil {
		return nil, err
	}
	return b.Save(content)
}

// buildMarkdown generates the markdown content
func (b *Builder) buildMarkdown(posts []types.PostWithAnalysis, now time.Time, totalScraped int) string {
	var sb strings.Builder

	// Header
	sb.WriteString("# X Digest\n\n")
	sb.WriteString(fmt.Sprintf("**Generated:** %s\n\n", now.Format("Monday, January 2, 2006 at 3:04 PM")))
	sb.WriteString(fmt.Sprintf("**Posts:** %d selected from %d scraped\n\n", len(posts), totalScraped))
	sb.WriteString("---\n\n")

	// Posts
	for i, p := range posts {
		sb.WriteString(b.formatPost(i+1, p))
		sb.WriteString("\n---\n\n")
	}

	// Footer
	sb.WriteString("*Generated by scroll4me*\n")

	return sb.String()
}

// formatPost formats a single post for the digest
func (b *Builder) formatPost(num int, p types.PostWithAnalysis) string {
	var sb strings.Builder

	// Post header with author
	sb.WriteString(fmt.Sprintf("## %d. @%s", num, p.Post.AuthorHandle))
	if p.Post.AuthorName != "" && p.Post.AuthorName != p.Post.AuthorHandle {
		sb.WriteString(fmt.Sprintf(" (%s)", p.Post.AuthorName))
	}
	sb.WriteString("\n\n")

	// Analysis summary
	if p.Analysis != nil {
		sb.WriteString(fmt.Sprintf("**Summary:** %s\n\n", p.Analysis.Summary))

		// Topics
		if len(p.Analysis.Topics) > 0 {
			sb.WriteString(fmt.Sprintf("**Topics:** %s\n\n", strings.Join(p.Analysis.Topics, ", ")))
		}

		// Relevance score
		sb.WriteString(fmt.Sprintf("**Relevance:** %.0f%%\n\n", p.Analysis.RelevanceScore*100))
	}

	// Original content
	sb.WriteString("### Post Content\n\n")
	sb.WriteString(fmt.Sprintf("> %s\n\n", formatQuote(p.Post.Content)))

	// Engagement metrics
	sb.WriteString(fmt.Sprintf("ðŸ“Š %d likes Â· %d retweets Â· %d replies\n\n",
		p.Post.Likes, p.Post.Retweets, p.Post.Replies))

	// Link
	if p.Post.OriginalURL != "" {
		sb.WriteString(fmt.Sprintf("ðŸ”— [View on X](%s)\n\n", p.Post.OriginalURL))
	}

	return sb.String()
}

// formatQuote formats text for markdown blockquote (handles newlines)
func formatQuote(s string) string {
	// Replace newlines with newline + quote prefix
	lines := strings.Split(s, "\n")
	return strings.Join(lines, "\n> ")
}

// GetLatestDigest returns the path to the most recent digest file
func GetLatestDigest(outputDir string) (string, error) {
	entries, err := os.ReadDir(outputDir)
	if err != nil {
		if os.IsNotExist(err) {
			return "", fmt.Errorf("no digests found")
		}
		return "", err
	}

	var latest string
	var latestTime time.Time

	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), "-digest.md") {
			continue
		}

		info, err := entry.Info()
		if err != nil {
			continue
		}

		if info.ModTime().After(latestTime) {
			latestTime = info.ModTime()
			latest = filepath.Join(outputDir, entry.Name())
		}
	}

	if latest == "" {
		return "", fmt.Errorf("no digests found")
	}

	return latest, nil
}
